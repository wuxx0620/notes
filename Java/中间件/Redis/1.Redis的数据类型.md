# String类型

## String类型数据的基本操作

- 添加/修改多个数据

  ```
  mset key1 value1 key2 value2...
  ```

- 获取多个数据

  ```
  mget key1 key2...
  ```

- 获取数据字符个数

  ```
  strlen key
  ```

- 追加信息到原始信息后部(如果原始信息存在就追加，否则新建)

  ```
  append key value
  ```

## String类型数据的扩展操作

### 数值增减操作

**大型企业级应用中，分库分表是基本操作，使用多张表存储同类型数据，但是对应的主键id必须保证统一性，不能重复。Oracle数据库具有sequence设定，可以解决该问题，但是Mysql数据库并不具有类似的机制，那么如何解决？**

> 解决方案

- 设置数值数据增加指定范围的值

  ```
  incr key
  incrby key increment
  incrbyfloat key increment
  ```

- 设置数值数据减少指定范围的值

  ```
  decr key
  decrby key increment
  ```

  

**String作为数值操作**

- String在redis内部存储默认就是一个字符串，当遇到增减类incr，decr是会转成数值型进行计算。
- redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个个执行的，因此无需考虑并发带来的数据影响。
- 注意：*按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。*

### 数据时效性设置

**业务场景**

新闻网站会出现热点新闻，热点新闻最大的特征是时效性，如何自动控制热点新闻的时效性。

> 解决方案

- 设置数据具有指定的生命周期

  ```
  setex key seconds value 
  psetex key milliseconds value
  ```

- redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作

## String类型数据操作的注意事项

1.**数据操作不成功的反馈与数据正常操作之间的差异**

​	①表示运行结果是否成功

​		(integer) 0 -> false 失败
​		(integer) 1 -> true 成功

​	②表示运行结果值

​		(integer) 3 -> 3 3个
​		(integer) 1 -> 1 1个

2.数据未获取到

​	（nil）等同于null

3.数据最大储存量

​	512MB

4.数值计算最大范围(Java中的Long最大值)
	9223372036854775807

## String类型应用场景

**业务场景**
主页高频访问信息显示控制，列如新浪微博大V主页显示粉丝数于微博数量

> 解决方案

- 在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可

  ![image-20210409171556477](img/image-20210409171556477.png)

- 在redis中以json格式存储大V用户信息，定时刷新(也可以使用hash类型)

![image-20210409171730397](img/image-20210409171730397.png)

- redis应用各种结构型和非结构型高热度数据访问加速

## Key的设置约定

> 数据库中的热点数据key命名惯例

| 表名  | 主键名 | 主键值   | 字段名 |
| ----- | ------ | -------- | ------ |
| order | id     | 23424    | name   |
| news  | id     | 32432432 | title  |

# hash类型

## hash类型数据的基本操作

**存储的困惑**

​	对象类数据的存储如果具有较频繁的更新需求操作会显得笨重

​	1、json存储，获取不方便

![image-20210409172414710](img/image-20210409172414710.png)

​	2、string存储，是三条数据

![image-20210409172439915](img/image-20210409172439915.png)

​	3、hash存储

​		新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息

​		需要的存储结构：一个存储空间保存多个键值对数据

​		hash类型：底层使用哈希表结构实现数据存储

​	![image-20210409172719741](img/image-20210409172719741.png)



> ​	hash存储结构优化

​	**如果field数量较少，存储结构优化为类数组结构**

​	**如果field数量较多，存储结构使用hashmap结构**

- 添加/修改数据

  ```
  hset key field value
  ```

  ![image-20210409174841827](img/image-20210409174841827.png)

- 获取数据

  ```
  hget key field
  hgetall key
  ```

  ![image-20210409174857276](img/image-20210409174857276.png)

- 删除数据

  ```
  hdel key field1 [field2]
  ```

- 添加/修改多个数据

  ```
  hmset key field1 value1 field2 value2
  ```

- 获取多个数据

  ```
  hmget key field1 field2...
  ```

- 获取哈希表中字段的数量

  ```
  hlen key
  ```

- 获取哈希表中是否存在指定的字段

  ```
  hexists key field
  ```


## hash类型数据扩展操作

- 获取哈希表中所有的字段名或字段值

  ```
  hkeys key
  hvals key
  ```

- 设置指定字段的数值世俗据增加指定范围的值

  ```
  hincrby key field increment
  hincrbyfloat key field increment
  ```

## hash类型数据操作的注意事项

- hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为null
- 每个hash可以存储2的32次方-1个键值对
- hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用
- hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈

## hash类型应用场景

**业务场景**

电商网站购物车设计与实现

![image-20210411195753792](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411195753792.png)

**业务分析**

- 仅分析购物车的redis存储模型
  - 添加、浏览、更改数量、删除、清空
- 购物车于数据库间的持久化同步
- 购物车于订单间的关系
  - 提交购物车：读取数据生成订单
  - 商家临时价格调整：隶属于订单级别
- 未登录用户购物车信息存储
  - cookie存储

> 解决方案

- 将客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息
- 将商品编号作为field，购买数量作为value进行存储
- 添加商品：追加全新的field与value
- 浏览：遍历hash
- 更改数量：自减\自增，设置value
- 删除商品：删除field
- 清空：删除key

![image-20210411201318788](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411201318788.png)

**当前设计是否加速了购物车的呈现？**

当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要二次查询数据库

- 每条购物车中的商品记录保存成两条field
- field1专用于保存购买数量
  - 命名格式：商品id:nums
  - 保存数据：数值
- field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等
  - 命名格式：商品id:info
  - 保存数据：json

![image-20210411201939787](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411201939787.png)

**商品信息大量重复，浪费空间**

将field2做成独立的hash，谁用谁去操作，**但是还是会出现重复操作问题**

缺省操作(没值操作，有值不进行操作)

```
hsetnx key field value
```

![image-20210411202804557](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411202804557.png)

**业务场景**
双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，没种商品抢购上限1000张

![image-20210411204317625](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411204317625.png)

> 解决方案

- 将商家id作为key
- 将参与抢购的商品id作为field
- 将参与抢购的商品数量作为对应的value
- 抢购是使用降值的方式控制商品数量



- 实际业务中还有超卖等实际问题，这里不做讨论
- redis应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计

**string存储对象(json)与hash存储对象**

 string存储讲究整体性  一次性更新 一次性添加 读为主

 hash更灵活 更新为主

# list类型

## list类型数据的基本操作

- 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分
- 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序
- list类型：保存多个数据，底层使用双向链表存储结构实现

![image-20210411205746493](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411205746493.png)

![image-20210411205849304](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411205849304.png

![image-20210411205916967](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411205916967.png)

- 添加/修改数据

  ```
  lpush key value1 [value2]...
  ```

- 获取数据

  ```
  lrange key start stop
  lindex key index
  llen key
  ```

  **从一侧添加数据，需要从对侧查询才能是正常顺序数据。**

  ![image-20210411210320502](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411210320502.png)

  **查询全部list数据**

  正确示例

  ```
  lrange key 0 -1
  ```

   错误示例

  ```
  lrange key -1 0
  ```

  

  ![image-20210411223002214](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411223002214.png)

- 获取并移除数据

  ```
  lpop key
  rpop key
  ```

  ![image-20210411223313894](C:\Users\YMXD\AppData\Roaming\Typora\typora-user-images\image-20210411223313894.png)

  

